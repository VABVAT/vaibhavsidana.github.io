---
layout: post
title: "Free items in a Network-Connected Vending Machine"
---
# Free items in a Network-Connected Vending Machine
---
## Abstract

This report documents a security research exercise conducted on a network-connected vending machine deployed in a college environment. The research uncovered critical API-level authorization and transaction state validation flaws that allowed unauthorized triggering of hardware actions. The issue demonstrated how common web security failures can translate directly into physical-world impact when present in IoT and edge devices. The vulnerability was responsibly disclosed to the vendor and subsequently addressed.

---

## Background and Motivation

The vending machine was newly deployed in a college setting and operated as a network-connected device. Given the increasing prevalence of IoT and edge devices that expose web-based interfaces, the system presented an opportunity to study how traditional web security failures can translate into real-world physical impact.

The goal of this research was to evaluate the machine’s security posture from the perspective of a network-adjacent attacker, without physical access to internal components.

---

## Threat Model

- Attacker is on the same local network as the vending machine
- No physical access to internal hardware
- No privileged credentials beyond a legitimate user purchase
- No modification of the device firmware

---

## System Overview

The vending machine exposed two primary services on the local network:

- A frontend web application running on port **3000**
- A backend service running on port **4000**

The backend service was responsible for both transaction handling and hardware control actions.

---

## Application Analysis

Accessing the frontend application remotely at `http://10.xx.xx.xx:3000` resulted in a partially rendered interface that closely resembled the vending machine’s on-device main menu. However, the transaction workflow did not complete.

Inspection of network activity revealed that the frontend application was hardcoded to communicate with a backend service at `localhost:4000`. This configuration functioned correctly on the vending machine itself, where both frontend and backend services were running locally. When accessed from an external client, however, the frontend failed to progress due to the absence of a corresponding backend service on the client’s localhost.

To fully analyze the application behavior and transaction flow, it was necessary to replicate the backend environment locally.

---
## Backend Replication and Transaction Flow

Using information inferred from frontend behavior and observed network requests, a minimal backend replica was implemented locally on the client machine listening on `localhost:4000`. This backend replica was created solely to satisfy the frontend’s expected API interactions and allow the user interface loaded from `10.xx.xx.xx:3000` to fully render and progress through the purchase workflow on the client device.

With the replicated backend running locally, the complete purchase flow was executed entirely from the personal device. This allowed full visibility into the sequence of backend API requests generated by the frontend during a successful transaction.

An intercepting proxy was used on the client machine to observe and analyze all requests issued by the frontend as the transaction completed. This revealed a consistent sequence of backend API calls corresponding to the final stage of the vending process.

These requests were responsible for initiating hardware access, triggering item dispensing, and closing hardware access. The requests succeeded only in generating network traffic when sent to the local backend replica, as no physical hardware was present on the client device.

This controlled environment made it possible to isolate and analyze the hardware-triggering requests without interacting directly with the vending machine during the transaction flow itself.

---
## Vulnerability Description

The critical issue arose from the backend’s handling of hardware-triggering API endpoints.

Several endpoints responsible for controlling physical hardware actions did not enforce:

- Authentication or session validation
- Verification of payment completion
- Binding to a valid transaction or order identifier

When these hardware-triggering requests were replayed against the local backend replica (`localhost:4000`), they failed as expected due to the absence of physical hardware.

However, when the same requests were sent directly to the vending machine’s backend service at `10.xx.xx.xx:4000`, the backend accepted them without validating transaction state or payment context and proceeded to execute the associated hardware actions.

This allowed the dispensing sequence to be triggered arbitrarily and repeatedly from an external client.

---

## Steps to Reproduce (Sanitized and High-Level)

> The following steps describe the reproduction process using placeholder IP addresses and generic endpoint names. Exact endpoints, parameters, and payloads are intentionally omitted.

1. **Identify Exposed Services**
   - Connect to the same local network as the vending machine.
   - Identify the vending machine at an internal address (e.g. `10.xx.xx.xx`).
   - Observe that:
     - The frontend application is exposed on `10.xx.xx.xx:3000`
     - The backend service is exposed on `10.xx.xx.xx:4000`

2. **Access the Frontend Remotely**
   - Open `http://10.xx.xx.xx:3000` in a browser on a separate machine.
   - Observe that the UI partially loads and resembles the vending machine’s main menu.
   - Note that the interface does not progress into a transaction flow.

3. **Identify Backend Dependency**
   - Inspect frontend network activity.
   - Observe that the frontend attempts to communicate with a backend service at `localhost:4000`.
   - Understand that this works on the vending machine itself (where the backend is running locally), but fails on an external client.

4. **Replicate Backend Locally**
   - Create a minimal backend service on the client machine listening on `localhost:4000`.
   - Implement only the responses required for the frontend to load and progress through its UI.
   - Reload `http://10.xx.xx.xx:3000` and confirm that the frontend now fully loads and allows interaction.

5. **Observe a Legitimate Transaction**
   - Perform a real purchase on the vending machine.
   - Use an intercepting proxy to observe requests sent to `10.xx.xx.xx:4000` during a successful transaction.
   - Identify a sequence of backend requests issued after payment completion that correspond to hardware control actions.

6. **Identify Hardware-Triggering Requests**
   - Observe three distinct backend requests made in sequence:
     - A request to open hardware access
     - A request to trigger item dispensing
     - A request to close hardware access
   - (Exact endpoint paths are intentionally omitted.)

7. **Test Requests Against Local Backend**
   - Replay the identified requests against `localhost:4000`.
   - Confirm that these requests fail, as no physical hardware is present.

8. **Trigger Hardware Actions Remotely**
   - Modify the destination of the same requests to target `10.xx.xx.xx:4000` instead of `localhost:4000`.
   - Send the requests from the external client machine.
   - Observe that the vending machine accepts the requests and triggers the corresponding hardware actions.

9. **Confirm Impact**
   - Repeat the request sequence to confirm that items can be dispensed without completing a payment.
   - Verify that the backend does not enforce transaction state, session binding, or payment verification.

---
## Impact

This vulnerability allowed a network-adjacent attacker to:

- Trigger vending machine hardware actions remotely
- Dispense items without completing a legitimate purchase
- Repeat the dispensing process in unlimited quantities

The issue demonstrates how missing server-side authorization and state validation at the API layer can escalate into physical exploitation when backend services directly control hardware components.

---

